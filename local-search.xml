<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nginx运维</title>
    <link href="/2024/12/20/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/nginx%E8%BF%90%E7%BB%B4/"/>
    <url>/2024/12/20/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/nginx%E8%BF%90%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>高可用方案</p><ul><li><code>Keepalived + Nginx</code>：常见高可用方案，适合中小型应用</li><li><code>LVS + Nginx</code>：需要更高性能和扩展性的系统</li><li><code>DNS + Nginx</code>：适用于分布式或全球业务</li><li>云服务（如AWS ALB, NGINX Plus, Kubernetes Ingress Controller）</li></ul><h3 id="基于-Keepalived-Nginx-的高可用方案"><a href="#基于-Keepalived-Nginx-的高可用方案" class="headerlink" title="基于 Keepalived + Nginx 的高可用方案"></a>基于 <code>Keepalived + Nginx</code> 的高可用方案</h3><h4 id="方案架构"><a href="#方案架构" class="headerlink" title="方案架构"></a>方案架构</h4><ul><li>两个<code>Nginx</code>实例：两台服务器运行<code>Nginx</code>作为负载均衡器</li><li><code>Keepalived</code>：管理虚拟IP，确保一台<code>Nginx</code>服务器宕机时，另一台<code>Nginx</code>服务器能接管虚拟<code>IP</code></li></ul><h4 id="方案细节"><a href="#方案细节" class="headerlink" title="方案细节"></a>方案细节</h4><p><strong>虚拟IP配置</strong></p><p>两台<code>Nginx</code>服务器上配置Keepalived，使用 VRRP协议创建一个虚拟<code>IP</code>(<code>VIP</code>)，该<code>IP</code>会在两台服务器之间切换</p><p><strong><code>Nginx</code>配置</strong></p><p>每台<code>Nginx</code>服务器运行相同的配置，负载均衡到后端服务器上。</p><p>如果有缓存需求，可以使用<code>Nginx</code>缓存模块提高性能</p><p><strong>健康检查</strong></p><p>通过<code>Keepalived</code>进行<code>Nginx</code>服务和后端服务器的健康检查。当<code>Nginx</code>实例本身或后端服务器出现问题时，进行故障转移</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ul><li>故障切换快：其中一台<code>Nginx</code>服务器宕机时，备份服务器会迅速接管<code>VIP</code>，保证业务不间断</li><li>配置简单</li><li>低成本：无需额外的硬件设备</li></ul><p><strong>缺点</strong></p><ul><li>单点故障问题：<code>Nginx</code>实现了高可用，如果后端应用服务器存在单点故障，整个系统仍然无法保持高可用</li><li>健康检查要求高：如果健康检查配置不当，导致虚拟<code>IP</code>频繁切换，从而影响业务的稳定性</li><li>性能瓶颈：<code>Keepalived</code>和<code>Nginx</code>会存在一定的性能开销，尤其是在高并发环境下，可能会成为瓶颈</li></ul><h3 id="基于-LVS-Linux-Virtual-Server-Nginx-的高可用方案"><a href="#基于-LVS-Linux-Virtual-Server-Nginx-的高可用方案" class="headerlink" title="基于 LVS (Linux Virtual Server) + Nginx 的高可用方案"></a>基于 <code>LVS (Linux Virtual Server) + Nginx</code> 的高可用方案</h3><h4 id="方案架构-1"><a href="#方案架构-1" class="headerlink" title="方案架构"></a>方案架构</h4><ul><li>**<code>LVS </code>(<code>Linux Virtual Server</code>)**：使用<code>LVS</code>作为负载均衡器，<code>Nginx</code>作为实际的反向代理和负载均衡服务。<code>LVS</code>提供对<code>TCP/IP</code>层的高效流量转发</li><li>**<code>Heartbeat</code>**：与<code>LVS</code>配合，使用<code>Heartbeat</code>实现高可用</li></ul><h4 id="方案细节-1"><a href="#方案细节-1" class="headerlink" title="方案细节"></a>方案细节</h4><p><strong><code>LVS</code>配置</strong></p><ul><li><code>LVS</code>作为第一层负载均衡，接收外部流量，转发到<code>Nginx</code>服务器</li><li><code>LVS</code>通过<code>Direct Routing</code>模式将流量直接转发到<code>Nginx</code>节点，从而减少负载均衡节点的负载</li></ul><p><strong><code>Heartbeat</code></strong></p><p><code>Heartbeat</code>会监控<code>LVS</code>的状态，当主<code>LVS</code>节点出现故障时，自动将流量切换到备份<code>LVS</code>节点</p><p><strong><code>Nginx</code>配置</strong></p><p>每台<code>Nginx</code>服务器配置相同</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ul><li>高效流量转发：提供更高的负载均衡能力，支持更高的并发和流量</li><li>灵活性：支持不同的负载均衡算法</li><li>可扩展性强：可方便增加更多<code>Nginx</code>节点水平扩展</li></ul><p><strong>缺点</strong></p><ul><li>配置复杂：相比<code>Keepalvied</code>，<code>LVS</code>和<code>Heartbeat</code>配置复杂度较高</li><li>调试难度大：多层负载均衡结构下，问题排查和调试难度大</li><li>依赖硬件条件：<code>LVS</code>的高效性对硬件条件较高，需要更好的网络带宽和服务器性能</li></ul><h3 id="基于DNS负载均衡-Nginx的高可用方案"><a href="#基于DNS负载均衡-Nginx的高可用方案" class="headerlink" title="基于DNS负载均衡+ Nginx的高可用方案"></a>基于<code>DNS</code>负载均衡<code>+ Nginx</code>的高可用方案</h3><h4 id="方案架构-2"><a href="#方案架构-2" class="headerlink" title="方案架构"></a>方案架构</h4><ul><li>使用<code>DNS</code>负载均衡机制。用户请求时，<code>DNS</code>服务器将请求的域名解析到可用的<code>Nginx</code>服务器<code>IP</code></li><li>配合健康检查，如果<code>Nginx</code>实例不可用，<code>DNS</code>将该实例的IP从解析记录中移除</li></ul><h4 id="方案细节-2"><a href="#方案细节-2" class="headerlink" title="方案细节"></a>方案细节</h4><p><strong>DNS负载均衡</strong></p><ul><li>配置多个A记录，指向不同Nginx实例IP地址</li><li>通过 <strong><code>Round Robin</code></strong> 或者基于 <strong><code>GeoDNS</code></strong> 的地理位置智能路由来实现流量分发</li></ul><p><strong>健康检查</strong></p><p>使用监控工具来检查<code>Nginx</code>服务器的健康状态，并动态更新<code>DNS</code>解析记录</p><p><strong><code>Nginx</code>配置</strong></p><p>每台<code>Nginx</code>服务器配置相同</p><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ul><li>简化运维：无需额外的负载均衡器</li><li>灵活性：<code>DNS</code>负载均衡允许快速扩展和调整服务器</li></ul><p><strong>缺点</strong></p><ul><li><code>DNS</code>缓存问题：<code>DNS</code>解析有缓存机制，服务器变动或故障时，更新<code>DNS</code>记录需要时间，导致请求仍被路由到有问题的<code>Nginx</code>服务器</li><li>健康检查延迟：<code>DNS</code>负载均衡的健康检查更新通常较慢，可能导致短时间内流量会路由到不可用的节点</li><li>不能处理<code>TCP</code>负载均衡：<code>DNS</code>负载均衡主要用于<code>HTTP/HTTPS</code>流量，若需要处理<code>TCP</code>协议，需要借助其它方案</li></ul><h3 id="基于-云服务（如AWS-ALB-NGINX-Plus-Kubernetes-Ingress-Controller）-的高可用方案"><a href="#基于-云服务（如AWS-ALB-NGINX-Plus-Kubernetes-Ingress-Controller）-的高可用方案" class="headerlink" title="基于 云服务（如AWS ALB, NGINX Plus, Kubernetes Ingress Controller） 的高可用方案"></a>基于 云服务（如<code>AWS ALB, NGINX Plus, Kubernetes Ingress Controller</code>） 的高可用方案</h3><h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h4><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>高度集成与自动化</strong>：利用云平台的管理服务，可以自动进行负载均衡、扩容、故障恢复等操作。</li><li><strong>可靠性高</strong>：云平台的负载均衡服务经过多年的优化，稳定性和可靠性都很高。</li><li><strong>弹性扩展</strong>：可以轻松地按需扩展Nginx实例和后端服务。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>成本较高</strong>：云服务通常会产生一定的费用，尤其是涉及到高流量或需要更多实例时。</li><li><strong>依赖于云平台</strong>：如果应用部署在多个云平台或者私有环境中，可能无法充分利用云平台的高可用服务</li></ul><h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><h3 id="工作节点进程数和线程数"><a href="#工作节点进程数和线程数" class="headerlink" title="工作节点进程数和线程数"></a>工作节点进程数和线程数</h3><p><code>worker_processes</code>决定了能够同时处理的请求数。理想的<code>worker_processes</code>数量通常是与CPU核心数相匹配</p><ul><li>如果服务器有多个CPU核心，建议将<code>worker_processes</code>设置为和CPU核心数相同或稍高</li><li>I&#x2F;O密集型(例如文件下载、视频流)应用，<code>worker_processes</code>可以设置为更高的值，以处理更多的并发请求</li><li>CPU密集型(例如数据计算)应用，<code>worker_processes</code>设置为CPU核心数比较合适</li></ul><p><strong>调整<code>worker_processes</code></strong></p><p>编辑<code>Nginx</code>配置文件修改参数</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span> auto;  <span class="hljs-comment"># 自动检测系统的 CPU 核心数</span><br></code></pre></td></tr></table></figure><p>手动设置数量</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span> <span class="hljs-number">4</span>;     <span class="hljs-comment"># 设置为 4，适用于 4 核 CPU</span><br></code></pre></td></tr></table></figure><p><strong>调整 <code>worker_connections</code></strong></p><p><code>worker_connections</code>控制每个<code>worker</code>进程最大连接数</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;  <span class="hljs-comment"># 每个 worker 进程最多支持 1024 个连接</span><br></code></pre></td></tr></table></figure><p><strong>调整 <code>worker_rlimit_nofile</code></strong></p><p><code>worker_rlimit_nofile</code> 设置每个<code>worker </code>进程可打开的最大文件描述符数</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_rlimit_nofile</span> <span class="hljs-number">100000</span>;  <span class="hljs-comment"># 增加每个 worker 进程的文件句柄限制</span><br></code></pre></td></tr></table></figure><h3 id="启用Gzip"><a href="#启用Gzip" class="headerlink" title="启用Gzip"></a>启用Gzip</h3><p>编译<code>Nginx</code>时启用<code>Gzip</code>模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --with-http_gzip_static_module --with-http_gzip_module<br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>添加<code>Nginx</code>配置文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    ...<br>    <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>; <span class="hljs-comment"># 开启Gzip压缩功能</span><br>    <span class="hljs-attribute">gzip_min_length</span> <span class="hljs-number">1k</span>; <span class="hljs-comment"># 设置最小压缩文件大小为1KB</span><br>    <span class="hljs-attribute">gzip_buffers</span> <span class="hljs-number">4</span> <span class="hljs-number">16k</span>; <span class="hljs-comment"># 设置压缩缓冲区个数和大小</span><br>    <span class="hljs-attribute">gzip_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>; <span class="hljs-comment"># 设置支持的HTTP协议版本为1.1</span><br>    <span class="hljs-attribute">gzip_comp_level</span> <span class="hljs-number">2</span>; <span class="hljs-comment"># 设置压缩级别为2（速度与压缩率的平衡）</span><br>    <span class="hljs-attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml; <span class="hljs-comment"># 设置需要压缩的文件类型</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><h4 id="配置浏览器缓存时间"><a href="#配置浏览器缓存时间" class="headerlink" title="配置浏览器缓存时间"></a>配置浏览器缓存时间</h4><p>设置HTTP响应头中的<code>Expires</code>和<code>Cache-Control</code>字段，可以控制浏览器缓存的时间</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~* \.(jpg|jpeg|gif|png|css|js)$</span> &#123;<br>    <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-string">&quot;public, max-age=31536000&quot;</span>; <span class="hljs-comment"># 设置静态资源的缓存时间为1年（单位：秒）</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="配置代理服务器缓存时间"><a href="#配置代理服务器缓存时间" class="headerlink" title="配置代理服务器缓存时间"></a>配置代理服务器缓存时间</h4><p>Nginx作为反向代理服务器使用，可以通过设置<code>proxy_cache_valid</code>和<code>proxy_cache_valid</code>指令来控制代理服务器的缓存时间</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://backend; <span class="hljs-comment"># 将请求转发到后端服务器</span><br>    <span class="hljs-attribute">proxy_cache</span> mycache; <span class="hljs-comment"># 启用缓存，命名为mycache</span><br>    <span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">200</span> <span class="hljs-number">302</span> <span class="hljs-number">60m</span>; <span class="hljs-comment"># 设置缓存有效时间为60分钟（单位：秒）</span><br>    <span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">404</span> <span class="hljs-number">1m</span>; <span class="hljs-comment"># 设置缓存有效时间为1分钟（单位：秒）</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化文件访问方式"><a href="#优化文件访问方式" class="headerlink" title="优化文件访问方式"></a>优化文件访问方式</h3><p>处理静态文件时，Nginx默认会将文件读取到内存中进行处理。这种方式在大文件或高并发情况下会导致内存消耗过大，影响性能。因此，可以采用优化文件访问方式来提高性能</p><h4 id="send-file"><a href="#send-file" class="headerlink" title="send_file"></a>send_file</h4><p><code>send_file()</code>函数可以直接将文件从磁盘读取并发送到网络，避免了数据在用户空间和内核空间之间的拷贝，提高了性能</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    ...<br>    <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>; <span class="hljs-comment"># 开启sendfile()函数支持功能（需要操作系统支持）</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="send-file-max-chunk"><a href="#send-file-max-chunk" class="headerlink" title="send_file_max_chunk"></a>send_file_max_chunk</h4><p>控制Nginx在发送文件时的最大分片大小</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    ...<br>    <span class="hljs-attribute">sendfile_max_chunk</span> <span class="hljs-number">1m</span>; <span class="hljs-comment"># 设置最大分片大小为1MB</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="tcp-nopush"><a href="#tcp-nopush" class="headerlink" title="tcp_nopush"></a>tcp_nopush</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    ...<br>    <span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>; <span class="hljs-comment"># 开启TCP_CORK选项</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p><code>log_format</code>指令格式</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">log_format</span> name format &#123;<span class="hljs-attribute">format</span> ...&#125;<br></code></pre></td></tr></table></figure><p><code>Nginx</code> 日志格式示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">log_format</span> compression <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] &#x27;</span><br>                       <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$request</span>&quot; <span class="hljs-variable">$status</span> <span class="hljs-variable">$bytes_sent</span> &#x27;</span><br>                       <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_referer</span>&quot; &quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$gzip_ratio</span>&quot;&#x27;</span>;<br><br><span class="hljs-attribute">access_log</span> /spool/logs/nginx-access.log compression buffer=<span class="hljs-number">32k</span>;<br></code></pre></td></tr></table></figure><p>更详细的自定义配置可以根据下面设置</p><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端IP地址，真实IP地址</td><td>211.28.65.253</td></tr><tr><td>$remote_user</td><td>客户端用户名称</td><td>–</td></tr><tr><td>$time_local</td><td>用日志格式下的本地时间和时区，服务器时间</td><td>18&#x2F;Jul&#x2F;2012:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求方式、URI和HTTP协议</td><td>“GET &#x2F;article-10000.html HTTP&#x2F;1.1”</td></tr><tr><td>$request_length</td><td>请求的长度（包括请求行，请求头和请求正文）</td><td></td></tr><tr><td>$request_time</td><td>请求处理时间，单位秒</td><td>0.205</td></tr><tr><td>$status</td><td>请求状态码，如200、302、404等</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送给客户端的字节数，不包括响应头大小</td><td>1547</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td><a href="http://www.wang.com/">www.wang.com</a> 192.168.100.100</td></tr><tr><td>$http_referer</td><td>来源页面地址，从哪个页面跳转到本页</td><td><a href="https://www.baidu.com/">https://www.baidu.com/</a></td></tr><tr><td>$http_user_agent</td><td>用户浏览器标识</td><td>“Mozilla&#x2F;4.0”</td></tr><tr><td>$http_x_forwarded_for</td><td>如果使用了代理，这个参数会记录代理服务器的ip和客户端的ip</td><td></td></tr><tr><td>$host</td><td>等同于$http_host</td><td></td></tr><tr><td>$uri</td><td>请求中的当前URI(不带请求参数，参数位于$args)</td><td></td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本</td><td>TLSv1</td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>上游服务器IP 地址和端口，或上游服务器的 UNIX 域套接字的路径，即真正提供服务的主机地址。在请求处理期间联系了多个服务器，则它们的地址用逗号分隔</td><td>192.168.1.1:80, 192.168.1.2:80, unix:&#x2F;tmp&#x2F;sock</td></tr><tr><td>$upstream_status</td><td>200</td><td></td></tr><tr><td>$upstream_response_time</td><td>从上游服务器接收响应所花费的时间，从建立连接、传输数据到关闭连接的时间</td><td>0.002</td></tr><tr><td>$upstream_header_time</td><td>从上游服务器接收响应头所花费的时间；时间以秒为单位，精度为毫秒。多个响应的时间用逗号和冒号分隔</td><td></td></tr><tr><td>$upstream_connect_time</td><td>与上游服务器建立连接所花费的时间；时间以秒为单位，精度为毫秒。如果是 SSL，则包括握手所花费的时间。多个连接的时间用逗号和冒号分隔</td><td></td></tr><tr><td>$upstream_bytes_received</td><td>从上游服务器接收的字节数，来自多个连接的值以逗号和冒号分隔</td><td></td></tr><tr><td>$upstream_bytes_sent</td><td>发送到上游服务器的字节数，来自多个连接的值以逗号和冒号分隔</td><td></td></tr><tr><td>$upstream_queue_time</td><td>请求在上游<a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html#queue">队列</a>中花费的时间，时间以秒为单位，精度为毫秒。多个响应的时间用逗号和冒号分隔</td><td></td></tr></tbody></table><h3 id="日志切分"><a href="#日志切分" class="headerlink" title="日志切分"></a>日志切分</h3><p><code>Nginx</code>本身不直接限制日志文件大小，可以通过以下方式对日志进行切分处理</p><ul><li>外部工具：<code>logrotate</code></li><li>Shell脚本</li><li><code>Nginx</code>日志分割模块</li></ul><p><code>Nginx</code>中日志路径配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">access_log</span> /var/log/nginx/access.log;<br><span class="hljs-attribute">error_log</span> /var/log/nginx/<span class="hljs-literal">error</span>.log;<br></code></pre></td></tr></table></figure><h4 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h4><p>针对<code>Nginx</code>日志，<code>logrotate</code>配置文件示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">/var/log/nginx/*.<span class="hljs-built_in">log</span> &#123;<br>    daily                      <span class="hljs-comment"># 每日切割</span><br>    rotate 7                   <span class="hljs-comment"># 保留 7 天的日志</span><br>    size 100M                  <span class="hljs-comment"># 单个日志文件限制为 100 MB</span><br>    compress                   <span class="hljs-comment"># 使用 gzip 压缩</span><br>    delaycompress              <span class="hljs-comment"># 延迟压缩到下次切割</span><br>    missingok                  <span class="hljs-comment"># 忽略日志缺失的错误</span><br>    notifempty                 <span class="hljs-comment"># 忽略空日志文件</span><br>    create 0640 nginx adm      <span class="hljs-comment"># 创建新的日志文件并设置权限</span><br>    sharedscripts<br>    postrotate<br>        [ -f /run/nginx.pid ] &amp;&amp; <span class="hljs-built_in">kill</span> -USR1 `<span class="hljs-built_in">cat</span> /run/nginx.pid` <span class="hljs-comment"># kill -USR1 信号通知 Nginx 重新打开日志文件</span><br>    endscript<br>&#125;<br></code></pre></td></tr></table></figure><p>将此配置保存到 <code>/etc/logrotate.d/nginx</code> 文件中，<code>logrotate</code> 会自动处理</p><p><strong>排查验证</strong></p><p>检查<code>logrotate</code>配置文件是否正确</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> logrotate -d /etc/logrotate.d/nginx<br></code></pre></td></tr></table></figure><ul><li><code>-d</code> 表示调试模式，不执行实际操作，仅显示执行过程。</li><li>如果有错误，输出日志会指出问题所在</li></ul><p>检查<code>Nginx</code>是否重新打开日志文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">postrotate<br>    [ -f /<span class="hljs-keyword">run</span><span class="language-bash">/nginx.pid ] &amp;&amp; <span class="hljs-built_in">kill</span> -USR1 `<span class="hljs-built_in">cat</span> /run/nginx.pid`</span><br>endscript<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 手动测试重启日志</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">kill</span> -USR1 $(<span class="hljs-built_in">cat</span> /run/nginx.pid)<br><span class="hljs-comment"># 检查Nginx错误日志</span><br><span class="hljs-built_in">tail</span> -n 20 /var/log/nginx/error.log<br></code></pre></td></tr></table></figure><p>检查<code>logrotate</code>定时任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 确认 cron 任务存在</span><br><span class="hljs-built_in">cat</span> /etc/cron.daily/logrotate<br><br><span class="hljs-comment"># 手动测试logrotate, -f 强制执行日志轮转</span><br><span class="hljs-built_in">sudo</span> /usr/sbin/logrotate -f /etc/logrotate.conf<br><br><span class="hljs-comment"># 查看日志轮转执行结果</span><br><span class="hljs-built_in">cat</span> /var/lib/logrotate/status<br></code></pre></td></tr></table></figure><h4 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h4><p>使用shell脚本进行切分<code>Nginx</code>日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>mv /var/log/nginx/access.log /var/log/nginx/access.log.old<br>mv /var/log/nginx/error.log /var/log/nginx/error.log.old<br>kill -USR1 $(cat /run/nginx.pid)<br><br></code></pre></td></tr></table></figure><p>可以自定义添加脚本许多其它功能：</p><ul><li>添加到<code>crontab</code>定时执行</li><li>压缩备份</li><li>添加备份日期等</li></ul><h4 id="Nginx日志分割模块"><a href="#Nginx日志分割模块" class="headerlink" title="Nginx日志分割模块"></a>Nginx日志分割模块</h4><p>按域名记录日志</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">log_format</span> custom <span class="hljs-string">&#x27;<span class="hljs-variable">$host</span> <span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] &#x27;</span><br>                   <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$request</span>&quot; <span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                   <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot;&#x27;</span>;<br><br><span class="hljs-attribute">map</span> <span class="hljs-variable">$host</span> <span class="hljs-variable">$log_file</span> &#123;<br>    host1.example.<span class="hljs-attribute">com</span> /var/log/nginx/host1.log;<br>    host2.example.<span class="hljs-attribute">com</span> /var/log/nginx/host2.log;<br>    <span class="hljs-attribute">default</span> /var/log/nginx/default.log;<br>&#125;<br><br><span class="hljs-attribute">access_log</span> /var/log/nginx/access.log custom;<br></code></pre></td></tr></table></figure><h2 id="Nginx监控"><a href="#Nginx监控" class="headerlink" title="Nginx监控"></a>Nginx监控</h2><p>使用<code>nginx_status</code>模块</p><p>启用<code>Nginx</code>状态监控页面<code>stub_status</code></p><p><code>nginx.conf</code>中启用<code>stub_status</code>模块</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">127.0.0.1:8080</span>;  <span class="hljs-comment"># 监听本地地址</span><br>    <span class="hljs-attribute">server_name</span> localhost;<br><br>    <span class="hljs-section">location</span> /nginx_status &#123;<br>        <span class="hljs-attribute">stub_status</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;<br>        <span class="hljs-attribute">allow</span> <span class="hljs-number">127.0.0.1</span>;   <span class="hljs-comment"># 仅允许本地访问</span><br>        <span class="hljs-attribute">deny</span> all;           <span class="hljs-comment"># 拒绝其他 IP 访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过访问 <code>http://localhost:8080/nginx_status</code>，看到以下信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Active</span> connections: <span class="hljs-number">10</span> <br><span class="hljs-attribute">server</span> accepts handled requests<br> <span class="hljs-attribute">19</span> <span class="hljs-number">19</span> <span class="hljs-number">19</span> <br><span class="hljs-attribute">Reading</span>: <span class="hljs-number">0</span> Writing: <span class="hljs-number">1</span> Waiting: <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><ul><li><strong>Active connections</strong>：当前活动的连接数。</li><li><strong>server accepts handled requests</strong>：接受、处理和响应的请求数量。</li><li><strong>Reading</strong>：正在读取请求头的连接数。</li><li><strong>Writing</strong>：正在发送响应的连接数。</li><li><strong>Waiting</strong>：保持连接空闲的数量（在 <code>keep-alive</code> 状态下）</li></ul>]]></content>
    
    
    <categories>
      
      <category>应用运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
